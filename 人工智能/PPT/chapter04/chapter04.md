[TOC]

# 对比几种搜索

![image-20221227211331152](chapter04/image-20221227211331152.png)

初始节点为S，目标节点为G。

1. 根据上图用先广搜索算法、先深搜索算法、代价一致算法、贪心算法和A star算法（五选三）实现搜索过程。

2. 分析上述五个算法的优缺点。

## 模拟五种算法运行过程

### BFS

广度优先搜索，从起点S出发，将相邻结点全部入队，队首每出一个结点就将其相邻结点入队，已经入队过得结点做标记，不再重复入队，因为能从起点到达它的位置的结点都会在它出队之前更新到达自己的最短距离。

<font color=blue>模拟上图的BFS搜索过程：</font>

左侧队首，右侧队尾

| 队列  | 操作                                                | 距离更新               |
| ----- | --------------------------------------------------- | :--------------------- |
| S     | S入队                                               | 更新最短距离SS=0       |
| A D   | S出队，其相邻结点A、D入队                           | SA=3; SD=2             |
| D B G | A出队，B、G入队                                     | SB=8; **SG=13**        |
| B G E | D出队，B、G、E入队，B已经在队列中了，不需要再次入队 | SB=3; SE=6             |
| G E C | B出队，C、E入队，E已经在队列中了，不需要再次入队    | SC=10; SE=min{5, 10}=5 |
| E C   | G出队                                               | **SG=13**              |
| C     | E出队                                               | **SG=9**               |
| [ ]   | C出队                                               | **SG=8**               |

队列为空，BFS搜索结束，SG最短距离为8。

### DFS

​	深度优先搜索，从起点出发，每找到一个点，就从该点出发去找下一个点，直到找到无点可走，则回溯到之前的结点继续向其他分支搜索。只要正在搜的结点不在栈里，就可以再次搜索。

<font color=blue>模拟上图的DFS搜索过程：</font>

左侧栈顶，右侧栈底

| 栈    | 操作            | 距离更新                          |
| ----- | --------------- | --------------------------------- |
| S     | S压栈           | SS=0                              |
| D A   | S弹栈，A、D压栈 | SA=3; SD=2                        |
| E B A | D弹栈，B、E压栈 | SB=3; SE=6                        |
| G B A | E弹栈，G压栈    | <font color=red>SG=10</font>      |
| B A   | G弹栈           | <font color=red>SG=10</font>      |
| E C A | B弹栈，C、E压栈 | SE=5; SC=5                        |
| G C A | E弹栈，G压栈    | <font color=red>SG=8</font>       |
| C A   | G弹栈           | <font color=red>SG=8</font>       |
| G A   | C弹栈,，G压栈   | <font color=red>SG=8</font>       |
| A     | G弹栈           | <font color=red>SG=8</font>       |
| G B   | A弹栈，B、G压栈 | SB=3; <font color=red>SG=8</font> |
| B     | G弹栈           | <font color=red>SG=8</font>       |
| E C   | B弹栈，C、E压栈 | SE=5; SC=5                        |
| G C   | E弹栈，G压栈    | <font color=red>SG=8</font>       |
| C     | G弹栈           | <font color=red>SG=8</font>       |
| G     | C弹栈，G压栈    | <font color=red>SG=8</font>       |
| []    | G弹栈           | <font color=red>SG=8</font>       |

此时栈为空，DFS搜索结束，SG最短距离为8

### **代价一致算法**

在BFS的基础上，不过不是盲目搜索，而是选择队列中距离最近的点来更新下一个结点。

<font color=blue>模拟上图的代价一致搜索过程：</font>

左侧小顶堆的堆顶，右侧堆底

| 优先队列 | 操作                                                   | 距离更新   |
| -------- | ------------------------------------------------------ | ---------- |
| S        | S入队                                                  | SS=0       |
| D A      | S出队，其相邻结点A、D入队，D的代价小，排在前面，SD最小 | SA=3; SD=2 |
| A B E    | D出队，B、E入队，按代价重新排列，SA最小                | SB=3; SE=6 |
| B E G    | A出队，G入队，按代价重新排列，SB最小                   | **SG=13**  |
| C E G    | B出队，C，E入队，按代价重新排列,SE,SC最小              | SC=5; SE=5 |
| E G      | C出队，G已经入队过了，不再入队，SE最小                 | SG=9       |
| G        | E出队，G已经入队过了，不再入队，SG最小                 | **SG=8**   |
| []       | G出队                                                  | **SG=8**   |

此时优先队列为空，搜索结束，SG最短距离为8

### 贪心算法

每次选择最短的一条路走

| 已选路径      | 操作                                               | 距离更新 |
| ------------- | -------------------------------------------------- | -------- |
| S->D          | S距离D最近，走D                                    | SD=2     |
| S->D->B       | D距离B最近，走B                                    | SB=3     |
| S->D->B->E    | <font color=green>B距离C,E一样近，随机选择C</font> | SC=5     |
| S->D->B->E->G | E距离G最近，走G                                    | SG=9     |

可以看到单纯贪心花费的时间很短，但是选择的路径是局部最优，未必是全局最优。中间绿色部分之所以没有选择走E，就是为了看到贪心的结果未必是最优解。

### A star算法

$A*$ 就是在代价一致算法的基础上，将权重从简单的边权，变成了一个全局的估计距离。估计距离由评估函数给出。通过评估函数选择一条尽可能快速逼近终点的路径进行搜索。

**估计函数：**
$$
f(n) = h(n) + g(n)
$$
$h(n)$ 表示从相邻点到达目标点的**估计距离**

$g(n)$ 表示从起点到达当相邻点 n 的**实际距离**，即已经搜出的答案

$f(n)$ 表示在 n 处从起点到终点的**综合估计值**

最常见的$h(n)$是利用曼哈顿距离或者欧拉距离作为估价函数来估计到达终点的距离。

曼哈顿距离：
$$
h(n) =  |x_1 - x_2| + |y_1 - y_2|
$$
欧拉距离：
$$
h(n) = \sqrt{(x_1 - x_2)^2 + (y_1-y_2)^2}
$$
再精准一点，可以使用BFS找到的最短距离作为估价距离$h(n)$,不过这样很慢

得到$f(n)$以后，利用这个综合估计值代替边权，作为**代价一致搜索**中优先队列的排序依据，其他的操作同代价一致搜索一致。



## 分析五种搜索的优缺点

**DFS：**可以很快判断出两点间是否连通。但是要找到最短路径，就需要遍历整颗递归树，有回溯的过程，运算速度慢。

**BFS：**可以找到起点到达目标点的所有路径。但是也要遍历所有的结点一次，才能找到最短路径。

**代价一致算法：**可以通过选择更短的路径更新结构，在路径选择的决策方面更合理。复杂度同BFS一致，不过，在队列空之前找到目标结点，就不需要继续遍历其他节点了，此时已经是最短的路径。

**贪心算法：**时间代价小。但是获取的路径可能不是最短的。

**A\*** 算法优点在于对环境反应迅速，搜索路径直接，是一种直接的搜索算法，因此被广泛应用于路径规划问题。 其缺点是实时性差，每一节点计算量大、运算时间长，而且随着节点数的增多，算法搜索效率降低，而且A* 算法并没有完全遍历所有可行解，所得到的结果不一定是最优解。

